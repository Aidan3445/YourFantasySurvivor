/**
 * Reads SVG files from src/assets/icons/ and generates React components
 * in src/components/icons/generated.tsx
 *
 * Usage: npx tsx scripts/generate-icons.ts
 *
 * Each SVG file becomes a named export matching the filename:
 *   torch.svg → TorchIcon
 *   tribal-council.svg → TribalCouncilIcon
 */

import fs from 'fs';
import path from 'path';

const ICONS_DIR = path.resolve('assets/icons');
const OUTPUT_FILE = path.resolve('src/components/icons/generated.tsx');

function toComponentName(filename: string): string {
  return (
    filename
      .replace(/\.svg$/, '')
      .split(/[-_]/)
      .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
      .join('') + 'Icon'
  );
}

function extractSvgInner(svg: string): { inner: string; attrs: Record<string, string> } {
  // Extract viewBox if present
  const attrs: Record<string, string> = {};
  const viewBoxMatch = /viewBox="([^"]+)"/.exec(svg);
  if (viewBoxMatch) attrs.viewBox = viewBoxMatch[1]!;

  // Extract everything between <svg ...> and </svg>
  const innerMatch = /<svg[^>]*>([\s\S]*)<\/svg>/i.exec(svg);
  if (!innerMatch) throw new Error('Could not parse SVG content');

  let inner = innerMatch[1]!;

  // Strip XML declarations, comments, <defs>, <style>, <filter>, <mask> blocks
  inner = inner
    .replace(/<\?xml[^?]*\?>/g, '')
    .replace(/<!--[\s\S]*?-->/g, '')
    .replace(/<style[\s\S]*?<\/style>/gi, '')
    .replace(/<defs[\s\S]*?<\/defs>/gi, '')
    .replace(/<filter[\s\S]*?<\/filter>/gi, '')
    .replace(/<mask[\s\S]*?<\/mask>/gi, '');

  // Remove class attributes (from Illustrator exports)
  inner = inner.replace(/\s*class="[^"]*"/g, '');

  // Replace hardcoded colors with currentColor so icons inherit from props
  // Matches fill="..." and stroke="..." with hex, rgb, named colors, etc.
  // Preserves fill="none" and stroke="none"
  inner = inner.replace(
    /fill="(?!none|currentColor)[^"]*"/g,
    'fill="currentColor"'
  );
  inner = inner.replace(
    /stroke="(?!none|currentColor)[^"]*"/g,
    'stroke="currentColor"'
  );

  // Convert SVG attributes to JSX (kebab-case → camelCase)
  inner = inner
    .replace(/stroke-width=/g, 'strokeWidth=')
    .replace(/stroke-linecap=/g, 'strokeLinecap=')
    .replace(/stroke-linejoin=/g, 'strokeLinejoin=')
    .replace(/fill-rule=/g, 'fillRule=')
    .replace(/clip-rule=/g, 'clipRule=')
    .replace(/clip-path=/g, 'clipPath=')
    .replace(/stroke-dasharray=/g, 'strokeDasharray=')
    .replace(/stroke-dashoffset=/g, 'strokeDashoffset=')
    .replace(/stroke-miterlimit=/g, 'strokeMiterlimit=')
    .replace(/stroke-opacity=/g, 'strokeOpacity=')
    .replace(/fill-opacity=/g, 'fillOpacity=')
    .replace(/font-family=/g, 'fontFamily=')
    .replace(/font-size=/g, 'fontSize=')
    .replace(/font-weight=/g, 'fontWeight=')
    .replace(/text-anchor=/g, 'textAnchor=')
    .replace(/xml:space="[^"]*"/g, '')
    .replace(/xmlns:xlink="[^"]*"/g, '');

  // Trim and clean up whitespace
  inner = inner.replace(/^\s+|\s+$/g, '').replace(/\n\s*\n/g, '\n');

  return { inner, attrs };
}

function generate() {
  if (!fs.existsSync(ICONS_DIR)) {
    console.error(`Icons directory not found: ${ICONS_DIR}`);
    process.exit(1);
  }

  const files = fs.readdirSync(ICONS_DIR).filter((f) => f.endsWith('.svg'));

  if (files.length === 0) {
    console.warn('No SVG files found in', ICONS_DIR);
    return;
  }

  const icons: { name: string; inner: string; viewBox: string }[] = [];

  for (const file of files) {
    const name = toComponentName(file);
    const svg = fs.readFileSync(path.join(ICONS_DIR, file), 'utf-8');
    try {
      const { inner, attrs } = extractSvgInner(svg);
      icons.push({ name, inner, viewBox: attrs.viewBox ?? '0 0 24 24' });
      console.log(`  ✓ ${file} → ${name}`);
    } catch (e) {
      console.error(`  ✗ ${file}: ${e as Error}`);
    }
  }

  const output = `// Auto-generated by scripts/generateIcons.ts — do not edit manually
/* eslint-disable react/jsx-indent */
import { type IconProps, createIcon } from '~/components/common/customIcon';
export type { IconProps };

${icons
      .map(
        ({ name, inner, viewBox }) => `export const ${name} = createIcon('${name}', '${viewBox}', () => (
  <>${inner}</>
));`
      )
      .join('\n\n')}
`
    .replace(/="([^"]*)"/g, '="$1"') // preserve JSX attributes
    .replace(/"/g, '\''); // change other " to '

  const dir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(OUTPUT_FILE, output, 'utf-8');
  console.log(`\nGenerated ${icons.length} icons → ${OUTPUT_FILE}`);
}

generate();
